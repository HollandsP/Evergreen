RunwayML API Docs and key: key_fe1aad17b1a47b49e804798e0f3663ffefdb5efdebdd14ba0ebfe226c93cdf69db5f4f58c3e742e9c5384ed2b77550a26faffa69be815248b25dfeb2096bd7bb

Set up an organization
First, sign up for an account in the developer portal. After signing up, you’ll be presented with an option to create a new organization. An organization corresponds to your integration, and contains resources like API keys and configuration.

Create a key
Once you’ve created an organization, click to the API Keys tab. You’ll create a new key, giving it a name. Call it something descriptive, like “Matt Testing” so you can revoke the key later if needed.

The key will be presented to you only once: immediately copy it someplace safe, like a password manager. We’ll never return the key in plaintext again; if you lose the key, you’ll need to disable it and create a new one.

Add credits
Before you can start using the API, you’ll need to add credits to your organization. Credits are used to pay for the compute resources used by your models. Visit the billing tab in the developer portal to add credits to your organization. A minimum payment of $10 (at $0.01 per credit) is required to get started.

Start your integration
Now that you have an organization and a key, you can start using Runway’s API.

Using your API key
When you make requests to the API, you’ll need to include your API key in the headers. Our SDKs will automatically add your key if it’s specified in the RUNWAYML_API_SECRET environment variable. You can export this in your shell for test purposes like so:

macOS and Linux
Windows
Terminal window
export RUNWAYML_API_SECRET="key_123456789012345678901234567890"

In a production environment, do not hard-code your key like this. Instead, securely load your key into environment variables using a secret manager or similar tool.

QuickStart
Using the API
Before starting, make sure you have followed the instructions in the setup page.

Talking to the API
Generating Video
Generating Images
In this example, we’ll use the gen4_turbo model to generate a video from an image using the text prompt “Generate a video”. You’ll want to replace the promptImage with a URL of an image and a promptText with your own text prompt.

Node
Python
Just testing
First, you’ll want to install the Runway SDK. You can do this with npm:

Terminal window
npm install --save @runwayml/sdk

In your code, you can now import the SDK and start making requests:

import RunwayML, { TaskFailedError } from '@runwayml/sdk';

const client = new RunwayML();

// Create a new image-to-video task using the "gen4_turbo" model
try {
  const task = await client.imageToVideo
    .create({
      model: 'gen4_turbo',
      // Point this at your own image file
      promptImage: 'https://example.com/image.jpg',
      promptText: 'Generate a video',
      ratio: '1280:720',
      duration: 5,
    })
    .waitForTaskOutput();

  console.log('Task complete:', task);
} catch (error) {
  if (error instanceof TaskFailedError) {
    console.error('The video failed to generate.');
    console.error(error.taskDetails);
  } else {
    console.error(error);
  }
}

Uploading base64 encoded images as data URIs
You can also upload base64 encoded images (as a data URI) instead of pointing to an external URL. This can be useful if you’re working with a local image file and want to avoid an extra network round trip to upload the image.

To do this, simply pass the base64 encoded image string as a data URI in the promptImage field instead of a URL. For more information about file types and size limits, see the Inputs page.

Node
Python
import fs from 'node:fs';
import RunwayML, { TaskFailedError } from '@runwayml/sdk';

const client = new RunwayML();

// Read the image file into a Buffer. Replace `example.png` with your own image path.
const imageBuffer = fs.readFileSync('example.png');

// Convert to a data URI. We're using `image/png` here because the input is a PNG.
const dataUri = `data:image/png;base64,${imageBuffer.toString('base64')}`;

// Create a new image-to-video task using the "gen4_turbo" model
try {
  const imageToVideo = await client.imageToVideo
    .create({
      model: 'gen4_turbo',
      // Point this at your own image file
      promptImage: dataUri,
      promptText: 'Generate a video',
      ratio: '1280:720',
      duration: 5,
    })
    .waitForTaskOutput();

  console.log('Task complete:', task);
} catch (error) {
  if (error instanceof TaskFailedError) {
    console.error('The video failed to generate.');
    console.error(error.taskDetails);
  } else {
    console.error(error);
  }
}


Models
The API exposes the following models (1 credit = $0.01):

Model Name
Input	Output	
Pricing
Learn More
gen4_turbo
Image	Video	
5 credits / sec
Guide Reference
gen4_image
Text/Image (References)	Image	
5 credits / 720p image
8 credits / 1080p image
Guide Reference
gen3a_turbo
Image	Video	
5 credits / sec
Guide Reference
upscale_v1
Video	Video	
2 credits / sec
Reference
act_two
Image or Video	Video	
5 credits / sec
Reference
Model outputs
Gen-3 Alpha Turbo outputs

720p videos in 5s or 10s duration in the following resolutions
1280:768
768:1280
Gen-4 Turbo outputs

720p videos in 5s or 10s duration in the following resolutions
1280:720
720:1280
1104:832
832:1104
960:960
1584:672

Pricing
Each generation you run in the Ruway API costs credits. Credits can be purchased for $0.01 per credit in the developer portal for an organization. Sales tax may apply depending on your location.

Model pricing
Model	Pricing
gen4_turbo	5 credits per second
gen4_image	5 credits per 720p image, or 8 credits per 1080p image
gen3a_turbo	5 credits per second
upscale_v1	2 credits per second
act_two	5 credits per second
Cost calculator
You can calculate the cost of your intended usage:

Images: 
1
 x 720p (5 credits) + 
1
 x 1080p (8 credits) = $0.13
Videos: 
1
 Duration: 
5s
 = $0.25


Go-live Checklist
Before going live, make sure that you’ve checked and double-checked that everything is in order. This is a checklist of things that you might not think of.

1. Manage your usage
Tier up
Limits on your organization are governed by tiers. If you haven’t done much testing or haven’t added many credits to your organization, your tier may not allow enough generations per day or enough concurrent generations to satisfy your users’ demand.

Tiering up involves adding credits and waiting set intervals (predetermined by the tier). If you have an estimate for how many generations you’ll be creating, you should tier up to a tier that allows for that many generations per day.

Set up autobilling
Make sure you have set up autobilling for your organization. Autobilling will ensure that your integration doesn’t run out of credits unexpectedly. To set up autobilling, you’ll set up a payment method to be charged. You’ll also provide a threshold below which your credit balance will be recharged at, and the number of credits to add.

You can learn more about autobilling in the autobilling docs.

2. Test your integration
Make sure you’ve tested your integration thoroughly. You should be sure that your integration can tolerate different kinds of failures, like 429 Too Many Requests errors (indicating your integration has reached the rate limit) and 503 Service Unavailable errors (indicating a service outage).

A full list of errors is documented on our errors page.

Check your integration’s validation
Also be sure to check the API documentation to ensure inputs that you are passing are validated. For example, passing a promptImage referencing an image that’s too large or an unsupported codec will result in a 400 Bad Request error. Test with a variety of inputs to ensure you haven’t missed any edge cases.

All URLs that you pass should be sure to follow the guidance in the inputs documentation.

3. Secure your integration
Keeping your integration secure is important to make sure your key is not abused. There are a few important steps to making sure your integration is built securely.

If you find that any key was stored insecurely, immediately disable the key. You can do this from the API Keys tab in the developer portal.

Ensure your key is stored securely
Your API key should never be hard-coded into your application. Instead, load your key from secure storage (like a secrets manager), or from environment variables that are set securely.

Double check that your key is not stored in your codebase, as anyone with access to your source code (or who obtains a copy of your source code) could abuse your key. You can easily search for your key with git grep:

Terminal window
# Search a git repository for Runway API key prefixes
git grep "key_"

Recommended key storage methods:

HashiCorp Vault
AWS Secrets Manager
Google Cloud Secret Manager
Azure Key Vault
Render environment variables
Heroku config vars
Stop sharing keys
Create API keys liberally and revoke them when they are no longer needed. If you have a staging environment, create a new API key for it that’s separate from your production API key. If you create keys for developers to test with on their local machines, each developer should have their own key.

Any keys that are shared between individuals or environments should be disabled and replaced.

4. Monitor your integration
Knowing how your integration is behaving in production is important for diagnosing issues. We recommend a few metrics for you to measure:

API error rate: While some errors are expected (like 404 Not Found errors when making idempotent task deletion requests), you should be sure that you are not receiving errors in production. Errors like 429 Too Many Requests indicate that your integration has been temporarily shut off after reaching a limit.
API request count: You should know how many requests your integration is making per day. This will help you understand how many credits you are using and how close you are to your tier limits.
Throttled task count: While it’s safe to treat tasks whose status is THROTTLED as though they are PENDING, too many throttled tasks could be a sign that your integration is approaching your generation limit.
Ensure you’re receiving emails
You’ll receive emails about your integration at the email address that you signed up for the developer portal with. Make sure that this email address is monitored and that emails from Runway are not being marked as spam. You’ll receive emails about autobilling charges and charge failures: failing to receive these notices may cause your integration to run out of credits.

Avoid account suspension
Runway will moderate unsafe requests. Too many moderated requests will lead to account suspension.

Ensure that the use case for your integration is not in our moderated categories. If needed, ensure you have implemented content moderation before making requests to Runway.


Runway API SDKs
Available SDKs
We provide SDKs as convenient helpers for interacting with our API. These SDKs use best practices and offer type safety, which helps to avoid errors and make it easier to write code.

Node.js
https://www.npmjs.com/package/@runwayml/sdk

The Node.js SDK includes TypeScript bindings. It is compatible with Node 18 and up, and can be installed with npm, yarn, or pnpm.

Python
https://pypi.org/project/runwayml/

The Python SDK includes type annotations compatible with MyPy. It is compatible with Python 3.8 and up.

Generating content
You can create content using our API using the methods documented in the API reference. For instance, POST /v1/text_to_image accepts input and produces an image as output.

Each API endpoint for starting a generation is available as a member on the SDKs. Here is a mapping of the API endpoints to the SDK methods:

Node
Python
Operation	API endpoint	Node.js SDK method
Generate an image	POST /v1/text_to_image	client.textToImage.create
Generate a video	POST /v1/image_to_video	client.imageToVideo.create
Video upscale	POST /v1/video_upscale	client.videoUpscale.create
Character performance	POST /v1/character_performance	client.characterPerformance.create
Calling these methods will create a task. A task is a record of the generation operation. The response from the method will look like this:

{
  "id": "17f20503-6c24-4c16-946b-35dbbce2af2f"
}

The id field is the unique identifier for the task. You can use this ID to retrieve the task status and output from the GET /v1/tasks/{id} endpoint, which is available as the tasks.retrieve method on the SDKs.

Node
Python
import RunwayML from '@runwayml/sdk';
const client = new RunwayML();

const task = await client.tasks.retrieve('17f20503-6c24-4c16-946b-35dbbce2af2f');
console.log(task);

The response from the method will look like this:

{
  "id": "17f20503-6c24-4c16-946b-35dbbce2af2f",
  "status": "PENDING",
  "createdAt": "2024-06-27T19:49:32.334Z"
}

The API reference documents the statuses that a task can be in, along with the fields that are available for each status.

Tasks are processed asychronously. The tasks.retrieve method returns the current status of the task, which you can poll until the task has completed. The task will eventually transition to a SUCCEEDED, CANCELED, or FAILED status.

When polling, we recommend using an interval of 5 seconds or more. You should also add jitter, and handle non-200 responses with exponential backoff. Avoid using fixed interval polling (such as with JavaScript’s setInterval), since latency from the API can cause the polling to be too frequent.

Built-in task polling
As a convenience, all SDK methods that return a task include a helper method that polls for the task output. This reduces the amount of code you need to write to wait for a task to complete.

Node
Python
The waitForTaskOutput method is present on the unawaited response from the create methods on textToImage, imageToVideo, and videoUpscale.

// ✅ Call `waitForTaskOutput` on the unawaited response from `create`
const imageTask = await client.textToImage
  .create({
    model: 'gen4_image',
    promptText: 'A beautiful sunset over a calm ocean',
    ratio: '1360:768',
  })
  .waitForTaskOutput();

console.log(imageTask.output[0]); // Print the URL of the generated image

// ✅ Getting the task ID for bookkeeping purposes

// Notice: no `await` here.
const imageTask = client.textToImage.create({
  model: 'gen4_image',
  promptText: 'A beautiful sunset over a calm ocean',
  ratio: '1360:768',
});

// Await the output of `create` to get the task ID
const taskId = (await imageTask).id;
console.log(taskId); // The task ID can be stored in your database, for instance.

// Wait for the task to complete. It is safe to await `waitForTaskOutput`
// after the output of `create` was awaited above.
const completedTask = await imageTask.waitForTaskOutput();

console.log(completedTask.output[0]); // Print the URL of the generated image

// ❌ If you await the response from `create`, the result not have access to
// `waitForTaskOutput`.
const awaitedImageTask = await client.textToImage.create({
  model: 'gen4_image',
  promptText: 'A beautiful sunset over a calm ocean',
  ratio: '1360:768',
});
const taskOutput = await awaitedImageTask.waitForTaskOutput();

If the task fails (that is, its status becomes FAILED), a TaskFailedError will be thrown. You should handle this error appropriately.

import { TaskFailedError } from '@runwayml/sdk';
try {
  const imageTask = await client.textToImage
    .create({
      model: 'gen4_image',
      promptText: 'A beautiful sunset over a calm ocean',
      ratio: '1360:768',
    })
    .waitForTaskOutput();
} catch (error) {
  if (error instanceof TaskFailedError) {
    // `taskDetails` contains the output of the tasks.retrieve call.
    console.error('Task failed:', error.taskDetails);
  } else {
    throw error;
  }
}

The waitForTaskOutput method accepts an optional options parameter. This parameter can be used to specify a timeout and an AbortSignal.

const imageTask = await client.textToImage
  .create({
    model: 'gen4_image',
    promptText: 'A beautiful sunset over a calm ocean',
    ratio: '1360:768',
  })
  .waitForTaskOutput({
    // Wait up to 5 minutes for the task to complete
    timeout: 5 * 60 * 1000,
    // Abort the task if the request is cancelled
    abortSignal: myAbortSignal,
  });

By default, waitForTaskOutput will wait for ten minutes before timing out. Upon timeout, a TaskTimedOutError will be thrown. Pass null to timeout to wait indefinitely. Disabling the timeout is not recommended as it may cause your server to experience issues if your Runway API organization reaches its concurrency limit or if Runway experiences an outage.

It is recommended to use an AbortSignal to cancel polling if you are using waitForTaskOutput in the handler for an incoming request, such as on a web server. Here is an example of how to correctly integrate this into your application:

Express.js
Koa
Socket.io
const runway = new RunwayML();

app.post('/generate-image', (req, res) => {
  // Create an AbortController that triggers when the request is closed
  // unexpectedly.
  const abortController = new AbortController();
  req.on('close', () => {
    abortController.abort();
  });

  // 🚨 When performing a generation, be sure to add appropriate rate limiting
  // and other safeguards to prevent abuse.
  try {
    const imageTask = await runway.textToImage
      .create({
        model: 'gen4_image',
        promptText: req.body.prompt,
        ratio: '1360:768',
      })
      .waitForTaskOutput({ abortSignal: abortController.signal });

    res.send(imageTask.output[0]);
  } catch (error) {
    if (error instanceof TaskFailedError) {
      res.status(500).send('Task failed');
    } else {
      throw error;
    }
  }
});

Danger

Triggering the abortSignal passed to waitForTaskOutput or hitting the passed timeout will not cancel the task. Cancelling the task must be done by invoking the cancellation endpoint.

In addition to the methods that create new tasks, the tasks.retrieve method also returns a promise with a waitForTaskOutput method. This method is equivalent to the waitForTaskOutput method on the unawaited response from the create methods.

const task = await client.tasks
  .retrieve('17f20503-6c24-4c16-946b-35dbbce2af2f')
  .waitForTaskOutput();
console.log(task.output[0]);

This is useful if you’d like to create a task in one request and wait for its output in another request, or for handling the case where the client disconnected before the task completed.

Be aware that you must still add error handling for TaskFailedError and TaskTimeoutError when using this method.

Inputs
When starting tasks through the Runway API, you’ll often need to provide assets like images. Some restrictions exist for what you can provide.

Assets can be provided via URLs or Data URIs.

URLs
In all cases, URLs must meet some basic minimum requirements:

All URLs must be HTTPS.
URLs must reference a domain name, not an IP address.
The server should respond with valid Content-Type and Content-Length headers.
Redirects are not followed. If the URL returns a 3XX response code, the request is considered failed.
The length of any single URL should not exceed 2048 characters.
The file size of the image asset that the URL points to should not exceed 16MB.
Additionally, the server responding to the request must support HTTP HEAD requests.

Content-Type values
When specifying a URL, the Content-Type response header must be specified, and it must match the media type of your asset. File extensions in URLs are not considered. The Content-Types that are supported are listed below for the supported asset types.

Be aware that application/octet-stream and other generic values are explicitly not supported.

User agent
Runway will use a User-Agent header that starts with RunwayML API/ when making requests to your server. If you use a scraping-prevention tool or WAF, be sure to allowlist our user agent string prefix.

Data URIs (base64 encoded images)
A data URI allows you to pass the base64 encoded images as part of a request to our API, rather than passing a URL to the asset hosted on another server. This can reduce the complexity of your integration by eliminating an upload step.

Data URIs are supported anywhere URLs are expected. However, they come with some restrictions:

The length of the encoded data URI must be under 5MB (1024 × 1024 × 5 bytes). Keep in mind that base64-encoding your asset increases its size by about 33%: this means that you may not be able to use data URIs with assets larger than about 3.3MB. This limit supersedes type-specific file size limits.
The data URI must include an appropriate content type string. For instance, your data URI should start with something like data:image/jpg;base64,.
If a data URI is not base64 encoded, it may not be accepted.

Considerations
If you do not already have your asset stored in object storage, submitting your asset with a data URI can save you a step. Using a data URI may also help to reduce the latency of API calls.

However, the ~3MB limit may be too small for some assets, especially for video. If you cannot be sure that all assets are safely within the 5MB un-encoded size limit, you should upload assets to object storage instead. Uploaded assets (in other words, using a URL) have a limit of 16MB per image.

Type-specific requirements
Images
For fields that accept images, the asset referenced by the URL must use one of the following codecs, along with the corresponding Content-Type header:

Codec	Content-Type header
JPEG	image/jpg or image/jpeg
PNG	image/png
WebP	image/webp
All images are limited to 16MB.

Videos
For fields that accept videos, the asset referenced by the URL must use one of the following codecs, along with the corresponding Content-Type header:

Codec	Content-Type header
MP4	video/mp4
webm	video/webm
mov	video/quicktime or video/mov
Ogg	video/ogg
H.246	video/h264
All videos are limited to 16MB.

Aspect ratios and auto-cropping
Gen-4 Turbo and Act-Two support Landscape 1280:720 1584:672 1104:832, Portrait 720:1280 832:1104 and Square 960:960 outputs.

Gen-3 Alpha Turbo supports 1280:768 or 768:1280 outputs.

If your input asset is not exactly of the above listed ratios, the model will auto-crop your asset from the center to the aspect ratio parameter provided.


Outputs
After a task succeeds, the GET /v1/tasks/:id endpoint will return a response like this:

{
  "id": "d2e3d1f4-1b3c-4b5c-8d46-1c1d7ee86892",
  "status": "SUCCEEDED",
  "createdAt": "2024-06-27T19:49:32.335Z",
  "output": [
    "https://dnznrvs05pmza.cloudfront.net/output.mp4?_jwt=..."
  ]
}

The output member will contain one or more URLs that link to the result of your generation.

It’s important to note that these URLs are ephemeral: they will expire within 24-48 hours of accessing the API. We expect you to download the data at this endpoint and save it to your own storage. Since these URLs will expire, do not expose them directly in your product.

Content Moderation
Runway takes the safety of its platform seriously. This means we will moderate certain API requests.

If your account makes too many requests that get moderated, we will suspend your account. If needed, you should add moderation before calling the Runway API, to avoid suspension.

Approach to Trust & Safety
Refer to our help center approach to trust & safety.

Moderated content categories
Refer to our help center FAQ guide on content moderation.

Moderated content types
Runway moderation will evaluate all elements of your request. This means your requests may be moderated for either an image or text prompt violation.

Moderation implications
Recommended moderation approach
We recommend reviewing the categories we block to determine what type of, if any, moderation you need in place.

Each call to Runway’s API defaults to auto moderation levels. If you wish to be less strict about preventing generations that include recognizable public figures, add the contentModeration object to your image or video generation API requests. See the API reference for details.

Cost of moderated generations
Moderated generations have the same credit cost as successful generations.

Account suspension
If your account makes too many moderated requests we will suspend it. You can appeal an account suspension here. Be sure to email from an email account associated with your developer portal login.

Moderation API responses
If a request was moderated, the task status response will return with "status":"FAILED".

Additional details describing the moderation appear in the "failure" and "failureCode" fields.

Why is my input getting content moderated?

Runway's content moderation system automatically scans your inputs and the resulting outputs for anything that is not allowed under our Usage Policy.

We are unable to allowlist specific accounts or subject matters that are being content moderated, regardless of the intent of your input or final project. Content moderation cannot be disabled for an account, project, or topic by the support team.

Autobilling
To help prevent your organization from running out of credits, you can use autobilling to automatically top up your organization’s credits.

Setting up autobilling
On the billing tab of your organization, choose the option to set up autobilling.

First, you’ll need to choose thresholds for autobilling:

The “recharge below” value is the threshold below which your credits should be topped up.
The “recharge amount” value is the number of credits that will be purchased. This must be at least 1000 credits (or $10).
Next, you’ll need to provide a payment method. You can add a payment method through Stripe.

Autobilling process
Every hour, we’ll check whether your credit balance has dropped below your autobilling “recharge below” threshold. If it has, we’ll attempt to charge the payment method on file for the number of credits specified by the “recharge amount”. Be aware that sales tax may be applied to the charge depending on your location.

If the payment fails, we’ll notify you by email. We’ll retry the charge after 24 hours. If the payment still fails, we’ll notify you by email and retry a final time 24 hours later. If all three attempts fail, we will not reattempt autobilling.

Fixing autobilling
Depending on the reason for the autobilling payment failure, you may or may not need to provide a new payment method. For example, a declined charge due to insufficient funds may not require a new payment method, while a declined charge due to an expired card will.

After providing the new payment details, you will have the option in the portal to manually trigger autobilling. If the manually-triggered payment succeeds, autobilling that has been stopped due to three successive failures will be re-enabled.

Tier considerations
Each usage tier specifies a maximum monthly spend amount. This is the maximum number of credits that can be purchased in any 30 day window. If your organization’s current usage tier has a remaining monthly spend that’s lower than your “recharge amount”, the recharge amount will be capped at the remaining monthly spend.

If your organization’s remaining monthly spend is below $10, autobilling will fail.

Usage Tiers and Limits
In order to protect our API against abuse and to ensure fair access to our models, we have limits in place that govern how many generations you can create.

Limits
Each organization in the API is subject to a set of limits. These limits are per-organization, not per-API key.

Concurrency limit
This is the maximum number of tasks the API will allow you to run concurrently. If you submit more tasks than this limit, your tasks will have a status of "THROTTLED", indicating that the task is stored on our servers but has not been enqueued for processing. Throttled tasks will be enqueued in approximately the order that they were submitted in.

In rare cases, you may experience lower than maximum concurrency depending on system load. If you are interested in guaranteed (minimum) concurrency, please contact us using the limits exception form in the usage page of the developer portal.

Concurrency limit example
To help you reason about how these limits work, here’s an example using some approximations.

Assume you want to generate 200 videos and you have a concurrency limit of 5:

You can submit all 200 video request tasks at the same time.
Runway handles the queueing logic and starts executing them in rapid fashion 5-at-a-time, in sequential order based on creation time.
The first 5 videos finish in 15 seconds and the 6th to 10th videos begin generating. They finish in 15 additional seconds.
All 200 videos are complete within 10 minutes (15 seconds x 200 videos / 5 concurrency).
No maximum requests-per-minute limit
There is no maximum requests-per-minute limit, as long as your requests are within your maximum daily generations limit.

If you submit more generations than can execute simultaneously on your concurrency limit, our API queues the additional requests. You do not need to add rate-limiting logic to your integration.

Maximum daily generations
This is the maximum number of generations you can create in a 24-hour rolling window. The limit resets continuously based on when each request was made, not at a fixed daily reset time.

If you exceed this limit, you’ll receive a 429 Too Many Requests response to the task creation request, indicating you’ve exceeded your quota.

Maximum monthly spend
This is the amount of money your organization is allowed to spend on credits in a 30-day window. You will be prevented from purchasing more than this amount, and autobilling will cap any automatic recharges at your remaining monthly spend.

Tiers
Each organization has a usage tier. The tier sets the limits of your organization.

Each model has specific limits determined by your tier, listed below.

Gen-4 Turbo
Gen-4 Image
Gen-3 Turbo
Act Two
Tier	Max concurrency	Max gens/day	Max spend/mo.	Criteria to reach tier
1	1	50	$100	
2	3	500	$500	1 day after $50 purchased
3	5	1,000	$2,000	7 days after $100 purchased
4	10	5,000	$20,000	14 days after $1,000 purchased
5	20	25,000	$100,000	7 days after $5,000 purchased
For custom tier information, higher limits, or guaranteed concurrency, file an exception request from the usage page when logged in to the developer portal. These and other benefits fall under enterprise partnerships


Organizations and Roles
You can add and remove members from your organization to share access to key management, usage stats, and billing setup.

Adding members to your organization
Visit the members page in the developer portal to invite members by email address.

If they do not already have an account, they will be prompted to create one and join your organization.

If they already have an account, they will see a notification in the developer portal that they have been invited to join your organization. (This appears under invitations on the top navigation bar.)

Organization roles
Currently, all members of an organization have the same level of permissions to take all actions as the organization owner, with the following exceptions:

Members cannot remove the organization owner.
Removing members from your organization
You can remove members from your organization by clicking the “Remove” button on the members page in the developer portal.


ERRORS
HTTP Errors
You may receive a variety of errors from our API. This matrix shows what you might expect, why, and whether it is safe to retry these requests.

HTTP Status	Description	May retry?
400	There is a problem with one of the inputs for the request. Expect a JSON response with an error member with a human-readable explanation of the problem.	No
401	The provided API key is not valid.	No
404	Requests will return a 404 when the referenced resource is not available	No
405	If an endpoint is called with a HTTP method that it does not support, this response code will be returned.	No
429	If the client makes too many requests to the API within a period of time, this response code will be returned. This may be returned when an integration’s limits have been reached.	Yes
502	This error is returned when Runway is shedding load	Yes
503	This error is returned when Runway is shedding load	Yes
504	This error is returned when Runway is overloaded and not able to satisfy the request	Yes
When retrying requests due to an error, implement exponential backoff and jitter. To implement jitter, add a random delay of up to 50% to your retry timing: doing this prevents thundering herds.

Note: Runway’s SDKs will handle retries automatically.

Task Failures
When a task fails, the Get Task endpoint endpoint returns a failureCode indicating the problem that occurred during processing.

SAFETY failures
Failure codes that start with SAFETY. indicate that the task was rejected because of content moderation. Content moderation is performed on both task inputs as well as outputs.

When a failure code is in the form SAFETY.INPUT.*, it indicates that one of the inputs contained content that was deemed unsupportable. When in the form SAFETY.OUTPUT.*, it indicates that content moderation rejected the output of the task.

The end of the failure code indicates the likely source of rejection. SAFETY.INPUT.TEXT, for instance, indicates that prompt text was rejected. If multiple inputs would be rejected, you will receive a failure for the first one that was tested.

While we make a best-effort attempt to ensure the accuracy of the third component of these failure codes, they may not correspond exactly to inputs. You may, for instance, receive a SAFETY.INPUT.TEXT failure on a task that provides no promptText argument. You should treat these as diagnostic messages only rather than exposing them to users.

Note

Unlike other failures, credits are not refunded for SAFETY failures.

You should not retry these generations.

INTERNAL.BAD_OUTPUT failures
Failure codes in the form INTERNAL.BAD_OUTPUT.* represent generations that were rejected by our internal systems for quality or system error reasons.

One possible cause for this failure is overlaid text or graphics present in input images that are not part of the scene itself. If you hit this error, we recommend avoiding using overlaid text or graphics in input images, and instead adding these to the task output.

You may retry these generations, but they are not likely to succeed.

INPUT_PREPROCESSING.SAFETY.TEXT
This failure code indicates that input prompt text was rejected for content moderation reasons.

You should not retry these generations.

INPUT_PREPROCESSING.INTERNAL
This failure code indicates that there was a problem performing content moderation.

You may retry these generations, but you should add a delay.

ASSET.INVALID
One of the inputs that you provided (an image, video, etc.) is not acceptable for the type of task that you ran. This often indicates a problem with the dimensions, duration, or other properties of the media you provided.

You should not retry these errors, as they indicate a problem with your inputs.

INTERNAL or a null value
INTERNAL or an undefined or null value indicates that there was an internal problem processing the task.

You may retry these generations, but you should add a delay.

Troubleshooting
Troubleshooting assets
When submitting an asset, the API may return a 400 Bad Request response if the asset cannot be used. If you’re using SDKs, a BadRequestError will be thrown in Node or raised in Python.

The message in the error response body will include two pieces of pertinent information: the field that the error occurred for (e.g., promptImage) and the reason for the failure.

Common error reasons
Invalid data URI.
The provided data URI is malformed and could not be parsed. Be sure you're using a library to encode the URI.
Unsupported asset type. Data URIs must include the content type of the value they encode.
Your data URI specifies a media type that's not supported. See the list of supported media types.
Invalid URL
You provided a URL that is non-standard and cannot be parsed.
Only HTTPS URLs are allowed.
All URLs must start with https://. You cannot use http:// or other schemes, like ftp://.
URLs must be hosted on a domain.
You cannot provide a URL that points to an IP address. For instance, https://11.22.33.44/foo/bar would be rejected. You can instead create an A or AAAA record for your domain that points at the IP address of your host (in the example here, an A record pointing to 11.22.33.44). Be sure to set up HTTPS on the host for that record.
Failed to fetch asset. The URL may be incorrect or the server hosting the asset may be down.
When we attempted to fetch the asset, we encountered a non-HTTP connection issue. This might be a DNS issue, TCP connection issue, TLS problem, protocol error, or an unexpectedly closed connection. Check that the URL is working and that connections are not being rejected.
Failed to fetch asset. Received HTTP response code "..."
When we attempted to fetch the asset, we did not get a 200 status code. The resposne code that we received is provided in the reason. Be aware that we do not follow redirects (via the Location HTTP response header).
Timeout while fetching asset.
It took longer than ten seconds to download the provided asset.
Assets must use an approved Content-Type response header. We received application/octet-stream, which is not allowed.
Your server returned application/octet-stream for the Content-Type HTTP response header. This is not allowed. See the list of supported media types.
Unsupported Content-Type response header: "...".
Your server returned an unsupported value for the Content-Type HTTP response header, which is noted in the response. See the list of supported media types.
Content-Length not provided
Your server did not specify a Content-Length HTTP response header. Lengths must be provided; we do not support streaming responses of unknown length.
Asset size exceeds XX.XMB.
Your server specified a Content-Length HTTP response header that exceeds the maximum size for the asset type. This error may also be returned if the number of bytes returned by the server does not match the number specified in the Content-Length response header. The maximum size is specified in the reason and in the inputs documentation.
Asset size exceeds XX.XMB.
Your server specified a Content-Length HTTP response header that exceeds the maximum size for the asset type. The maximum size is specified in the reason.
Invalid asset dimensions. Height and width must not exceed 8000px. Got XXxYY.
The provided asset is larger than 8000px on one of its sides. Assets must be less than 8000px on either side.
Invalid asset aspect ratio. width / height ratio must be between XX and YY. Got ZZ.
The aspect ratio (the asset width divided by the asset height) must be between the values XX and YY. The computed aspect ratio is included in the reason as ZZ.
Debugging failures
You can investigate the cause(s) for many common failures by simulating our request for your asset. To do this, we’ll run a cURL command against the URL you’ll specify for your asset. For this example, we’ll use the asset URL https://example.com/assets/image.jpg.

Terminal window
curl "https://example.com/assets/image.jpg" \
   -I \
   -H "User-Agent: RunwayML API/1.0"

You’ll receive output that looks like this:

% curl "https://example.com/assets/image.jpg" \
   -I \
   -H "User-Agent: RunwayML API/1.0"
HTTP/2 200
content-type: image/jpg
content-length: 123456
vary: Accept-Encoding
cache-control: max-age=14400
accept-ranges: bytes
alt-svc: h3=":443"; ma=86400

Your server should be returning a 200 status code.
Be sure you’re returning an acceptable Content-Type.
A Content-Length should be provided with an accurate file size.

The Runway API uses an X-Runway-Version HTTP request header to specify which version of the API to use. This is in the form of a date, like 2024-11-06. When you build an integration, setting a version header changes the default behavior of our API.

When is a new version number created?
We’ll add new features and functionality to the latest existing API version so long as the functionality can be added in a backwards-compatible way. You’ll be able to enjoy these features automatically without having to make changes to your integration.

A new version will only be created when we make changes to the API that are not backwards-compatible. Here are a few examples of what might result in a new API version:

The type of an input parameter is changed. For instance, if a parameter that was previously a string representing a URL becomes an object containing more information about the asset referenced by the URL.
The name of an input parameter is changed. For example, we may restructure an API to better reflect new techniques or model constraints. An input that was previously a boolean to enable a feature may be changed to an object to allow extra configuration to be provided beyond.
Functionality is removed. If we deprecate a feature, we’ll create a new API version that removes the functionality.
Version support
We’ll offer support for old API versions for four months after a new version is created. After that date, API requests with an old API version may be rejected.

Managing versions
We strongly suggest using one of the official Runway API SDKs. We’ll publish new major versions of each SDK when a new API version is released. Using TypeScript or a Python type checker like MyPy, you’ll be able to easily identify any places where your integration needs to be updated.

/v1 URLs
While we include /v1/ in our URLs, this is not used for versioning the API. We include this to reserve the ability to offer new functionality concurrently with our /v1/ endpoints in the future.

API Version 2024-11-06
The 2024-11-06 API version introduces changes to the /v1/image_to_video endpoint.

ratio
The ratio parameter no longer accepts 16:9 and 9:16. Instead, it now accepts the resolution for the output video directly. The accepted values are:

1280:768
768:1280
These new values will be accepted by the previous API version (2024-09-13), allowing you to incrementally upgrade, however be aware that this older API version will be phased out over time.

promptImage
The promptImage parameter was previously defined as a string. It is now equivalent to the following:

TypeScript
Python
type promptImage =
  | string
  | Array<{
    uri: string;
    position: 'first' | 'last';
  }>;

The following two are equivalent:

{
  "promptImage": "https://example.com/image.jpg"
}

{
  "promptImage": [
    {
      "uri": "https://example.com/image.jpg",
      "position": "first"
    }
  ]
}

If you were to set position to "last", the generated video will end with the image instead of starting with it.

{
  "promptImage": [
    {
      "uri": "https://example.com/image.jpg",
      "position": "last"
    }
  ]
}

You can also pass two images to the promptImage parameter:

{
  "promptImage": [
    {
      "uri": "https://example.com/image1.jpg",
      "position": "first"
    },
    {
      "uri": "https://example.com/image2.jpg",
      "position": "last"
    }
  ]
}

In the above example, the generated video will start with image1.jpg and end with image2.jpg.

Caution

Each image in the promptImage array must have a unique position.

seed
The maximum value of seed is now 4294967295 (or 2^32 - 1), up from 999999999.
